/*
 * This file is part of Audio Player Power-up for Trello.
 *
 * Copyright (c) 2025 Viktor Jevdokimov, Vilnius, Lithuania
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
// SPDX-License-Identifier: LGPL-2.1-or-later


/* Auto-generated by scripts/build-popup.mjs. Do not edit directly. */
(function(){
// Source: src/trello-power-up/popup/dom.js
const dom = {
  audioPlayer: document.getElementById('audio-player'),
  attachmentsList: document.getElementById('attachments-list'),
  waveformView: document.getElementById('waveform-view'),
  waveformTemplate: document.getElementById('waveform-template'),
  attachmentTemplate: document.getElementById('attachment-template'),
  playPauseButton: document.getElementById('play-pause-button'),
  abButton: document.getElementById('ab-button'),
  modal: document.getElementById('waveform-modal'),
  cancelBtn: document.getElementById('cancel-waveform'),
  authorizeBtn: document.getElementById('authorize-button'),
  attachmentsContainer: document.getElementById('attachments-container'),
  authForm: document.getElementById('auth-form'),
  apiKeyInput: document.getElementById('apikey-input'),
  pitchSlider: document.getElementById('pitch-slider'),
  pitchDisplay: document.getElementById('pitch-display'),
  speedSlider: document.getElementById('speed-slider'),
  speedDisplay: document.getElementById('speed-display'),
  prevButton: document.getElementById('prev-button'),
  nextButton: document.getElementById('next-button'),
  stopButton: document.getElementById('stop-button')
};

// Source: src/trello-power-up/popup/waveform-preview.js
class WaveformPreview extends HTMLElement {
  constructor() {
    super();
    const template = dom.waveformTemplate;
    if (template) {
      const frag = template.content.cloneNode(true);
      this.appendChild(frag);
    }
    this.canvas = this.querySelector('.waveform-canvas');
    this.wrench = this.querySelector('.wrench');
    this.placeholder = this.querySelector('.waveform-placeholder');
    this.status = this.querySelector('.waveform-status');
    this.loadingTimer = null;
    this.regionsPlugin = null;
    this.abLoopRegion = null;
    this.abRegionUpdateListener = null;
    this.abRegionRemovalListener = null;
  }

  createPlayer(options = {}) {
    if (this.wavesurfer) {
      this.wavesurfer.destroy();
    }
    if (this.canvas) {
      this.canvas.innerHTML = '';
    }
    this.abLoopRegion = null;
    this.regionsPlugin = null;
    this.zoomPlugin = null;
    const abortController = new AbortController();
    const signal = abortController.signal;
    const plugins = [];
    if (WaveSurfer?.Regions?.create) {
      this.regionsPlugin = WaveSurfer.Regions.create({
        dragSelection: false
      });
      plugins.push(this.regionsPlugin);
    }
    if (WaveSurfer?.Zoom?.create) {
      this.zoomPlugin = WaveSurfer.Zoom.create({
        scale: 0.5,
        maxZoom: 100,
        exponentialZooming: true
      });
      plugins.push(this.zoomPlugin);
    }
    const mergedOptions = {
      container: this.canvas,
      height: 80,
      normalize: true,
      minPxPerSec: 1,
      fetchParams: { signal },
      ...options
    };
    const optionPlugins = Array.isArray(mergedOptions.plugins) ? mergedOptions.plugins : [];
    if (plugins.length > 0 || optionPlugins.length > 0) {
      mergedOptions.plugins = [...optionPlugins, ...plugins];
    }
    this.wavesurfer = WaveSurfer.create(mergedOptions);
    this.wavesurfer.on('destroy', () => {
      abortController.abort();
    });
    if (this.regionsPlugin) {
      this.regionsPlugin.on('region-updated', (region) => {
        if (this.abLoopRegion && region && region.id === this.abLoopRegion.id) {
          this.abLoopRegion = region;
          if (this.abRegionUpdateListener) {
            this.abRegionUpdateListener(region.start, region.end);
          }
        }
      });
      this.regionsPlugin.on('region-removed', (region) => {
        if (this.abLoopRegion && region && region.id === this.abLoopRegion.id) {
          this.abLoopRegion = null;
          if (this.abRegionRemovalListener) {
            this.abRegionRemovalListener();
          }
        }
      });
    }
    return this.wavesurfer;
  }

  loadFromData(peaks, duration, options = {}) {
    this.createPlayer({
      ...options,
      peaks,
      duration
    });
    this.hideLoading();
    this.hideStatus();
  }

  loadFromUrl(url, options = {}) {
    this.showLoading();
    this.createPlayer({
      ...options,
      url
    });
    if (this.wavesurfer) {
      this.wavesurfer.once('ready', () => {
        this.hideLoading();
      });
      this.wavesurfer.once('error', () => {
        this.hideLoading();
      });
    }
  }

  clear() {
    if (this.wavesurfer) {
      this.wavesurfer.destroy();
      this.wavesurfer = null;
    }
    this.abLoopRegion = null;
    this.regionsPlugin = null;
    this.zoomPlugin = null;
    if (this.canvas) {
      this.canvas.innerHTML = '';
    }
    this.hideLoading();
    this.hideStatus();
  }

  showLoading() {
    this.classList.add('loading');
    this.hideStatus();
    if (this.loadingTimer) {
      clearTimeout(this.loadingTimer);
      this.loadingTimer = null;
    }
    if (this.placeholder) {
      this.placeholder.classList.add('hidden');
      const timer = setTimeout(() => {
        if (this.classList.contains('loading') && this.placeholder) {
          this.placeholder.classList.remove('hidden');
        }
        if (this.loadingTimer === timer) {
          this.loadingTimer = null;
        }
      }, 3000);
      this.loadingTimer = timer;
    }
  }

  hideLoading() {
    this.classList.remove('loading');
    if (this.loadingTimer) {
      clearTimeout(this.loadingTimer);
      this.loadingTimer = null;
    }
    if (this.placeholder) {
      this.placeholder.classList.add('hidden');
    }
  }

  showStatus(message) {
    if (!this.status) return;
    this.hideLoading();
    this.status.textContent = message;
    this.status.classList.remove('hidden');
  }

  hideStatus() {
    if (!this.status) return;
    this.status.textContent = '';
    this.status.classList.add('hidden');
  }

  setAbRegionUpdateHandler(handler) {
    this.abRegionUpdateListener = handler;
  }

  setAbRegionRemovalHandler(handler) {
    this.abRegionRemovalListener = handler;
  }

  setAbLoopRegion(start, end) {
    if (!this.regionsPlugin || !this.wavesurfer) {
      return null;
    }
    const sanitizedStart = Math.max(0, Number(start) || 0);
    const sanitizedEnd = Math.max(sanitizedStart, Number(end) || sanitizedStart);
    const styles = getComputedStyle(document.documentElement);
    const regionColor = styles.getPropertyValue('--waveform-region-color')?.trim() || 'rgba(110, 170, 255, 0.3)';
    const handleColor = styles.getPropertyValue('--waveform-region-handle-color')?.trim() || 'rgba(150, 190, 255, 0.75)';
    if (this.abLoopRegion) {
      this.abLoopRegion.remove();
      this.abLoopRegion = null;
    }
    this.abLoopRegion = this.regionsPlugin.addRegion({
      start: sanitizedStart,
      end: sanitizedEnd,
      drag: true,
      resize: true,
      color: regionColor,
      handleColor
    });
    if (this.abRegionUpdateListener) {
      this.abRegionUpdateListener(this.abLoopRegion.start, this.abLoopRegion.end);
    }
    return this.abLoopRegion;
  }

  clearAbLoopRegion() {
    if (this.abLoopRegion) {
      this.abLoopRegion.remove();
      this.abLoopRegion = null;
    }
  }

  exportPeaks() {
    return this.wavesurfer.exportPeaks({ channels: 1, maxLength: 600, precision: 1000 });
  }

  getDuration() {
    return this.wavesurfer?.getDuration();
  }

  setWrenchHandler(handler) {
    if (this.wrench) this.wrench.onclick = handler;
  }
}

function registerWaveformPreview() {
  if (!customElements.get('waveform-preview')) {
    customElements.define('waveform-preview', WaveformPreview);
  }
}

// Source: src/trello-power-up/popup/state.js
const state = {
  currentAttachmentIndex: 0,
  m4aAttachments: [],
  currentLoadRequest: 0,
  desiredPitchSemitones: 0,
  desiredPlaybackSpeed: 1,
  isAudioLoaded: false,
  abPointA: null,
  abPointB: null,
  abRepeatActive: false,
  isClearingAbRegion: false,
  trelloToken: null,
  apiKey: '',
  currentObjectUrl: null,
  popup: null,
  authMessageHandler: null,
  audioContext: null,
  soundtouchNode: null,
  audioSourceNode: null,
  soundtouchModulePromise: null
};

const caches = {
  audioBlobCache: new Map(),
  attachmentDurations: new Map()
};

// Source: src/trello-power-up/popup/constants.js
const PROXY_URL = window.trelloPlayerConfig?.proxyUrl;

const AUDIO_CACHE_LIMIT = 6;
const PITCH_MIN = -7;
const PITCH_MAX = 7;
const PITCH_KEY_PREFIX = 'pitch:';
const PLAYBACK_SPEED_MIN = 0.5;
const PLAYBACK_SPEED_MAX = 1;
const PLAYBACK_SPEED_STEP = 0.05;
const AB_MIN_DURATION = 0.05;

// Source: src/trello-power-up/popup/audio-helpers.js
function isAudioPlaying() {
  const { audioPlayer } = dom;
  return Boolean(audioPlayer && !audioPlayer.paused && !audioPlayer.ended && audioPlayer.currentTime >= 0);
}

function getCurrentTrackDuration() {
  const { audioPlayer, waveformView } = dom;
  if (audioPlayer && Number.isFinite(audioPlayer.duration) && audioPlayer.duration > 0) {
    return audioPlayer.duration;
  }
  if (waveformView && typeof waveformView.getDuration === 'function') {
    const waveformDuration = waveformView.getDuration();
    if (Number.isFinite(waveformDuration) && waveformDuration > 0) {
      return waveformDuration;
    }
  }
  const attachmentId = audioPlayer?.dataset?.attachmentId;
  if (attachmentId) {
    const storedDuration = caches.attachmentDurations.get(attachmentId);
    if (Number.isFinite(storedDuration) && storedDuration > 0) {
      return storedDuration;
    }
  }
  return null;
}

function formatDuration(seconds) {
  if (!Number.isFinite(seconds) || seconds <= 0) {
    return null;
  }
  const totalSeconds = Math.floor(seconds);
  const minutes = Math.floor(totalSeconds / 60);
  const remainingSeconds = totalSeconds % 60;
  const paddedMinutes = String(minutes).padStart(2, '0');
  const paddedSeconds = String(remainingSeconds).padStart(2, '0');
  return `${paddedMinutes}:${paddedSeconds}`;
}

// Source: src/trello-power-up/popup/ab-loop.js
function createAbLoopController() {
  const { audioPlayer, abButton, waveformView } = dom;

  function hasValidAbLoop() {
    return (
      state.abRepeatActive &&
      state.abPointA !== null &&
      state.abPointB !== null &&
      state.abPointB - state.abPointA >= AB_MIN_DURATION
    );
  }

  function updateAbButtonState() {
    if (!abButton) return;
    const hasA = state.abPointA !== null;
    const hasB = state.abPointB !== null;
    const active = hasValidAbLoop();
    abButton.classList.toggle('active', active);
    abButton.classList.toggle('pending', hasA && !hasB && !active);
    abButton.setAttribute('aria-pressed', String(active));
    if (active) {
      abButton.title = 'Clear A|B repeat';
    } else if (hasA && !hasB) {
      abButton.title = 'Set B point for A|B repeat';
    } else {
      abButton.title = 'Set A|B repeat points';
    }
  }

  function setAbButtonEnabled(enabled) {
    if (!abButton) return;
    abButton.disabled = !enabled;
    if (!enabled) {
      abButton.classList.remove('active', 'pending');
      abButton.setAttribute('aria-pressed', 'false');
      abButton.title = 'Set A|B repeat points';
    }
    updateAbButtonState();
  }

  function ensureAbLoopRegion() {
    if (!waveformView || typeof waveformView.setAbLoopRegion !== 'function') {
      return;
    }
    if (hasValidAbLoop()) {
      waveformView.setAbLoopRegion(state.abPointA, state.abPointB);
    } else if (!state.abRepeatActive && typeof waveformView.clearAbLoopRegion === 'function') {
      state.isClearingAbRegion = true;
      waveformView.clearAbLoopRegion();
      state.isClearingAbRegion = false;
    }
  }

  function resetAbLoop() {
    state.abPointA = null;
    state.abPointB = null;
    state.abRepeatActive = false;
    if (waveformView && typeof waveformView.clearAbLoopRegion === 'function') {
      state.isClearingAbRegion = true;
      waveformView.clearAbLoopRegion();
      state.isClearingAbRegion = false;
    }
    updateAbButtonState();
  }

  function enforceAbLoop() {
    if (!hasValidAbLoop()) {
      return;
    }
    const current = dom.audioPlayer.currentTime;
    const loopStart = state.abPointA;
    const loopEnd = state.abPointB;
    if (loopEnd <= loopStart) {
      return;
    }
    if (current >= loopEnd - 0.02) {
      dom.audioPlayer.currentTime = loopStart;
      if (dom.audioPlayer.paused && !dom.audioPlayer.ended) {
        dom.audioPlayer.play().catch(() => {});
      }
    }
  }

  function primePlaybackForAbLoop() {
    if (!hasValidAbLoop()) {
      return;
    }
    const loopStart = state.abPointA;
    const loopEnd = state.abPointB;
    if (loopEnd <= loopStart) {
      return;
    }
    if (dom.audioPlayer.currentTime < loopStart || dom.audioPlayer.currentTime >= loopEnd) {
      dom.audioPlayer.currentTime = loopStart;
    }
  }

  function handleAbButtonClick() {
    if (!abButton || abButton.disabled || !audioPlayer || !audioPlayer.src) {
      return;
    }

    if (hasValidAbLoop()) {
      resetAbLoop();
      return;
    }

    if (state.abPointA === null) {
      const playing = isAudioPlaying();
      state.abPointA = playing ? audioPlayer.currentTime : 0;
      state.abPointB = null;
      state.abRepeatActive = false;
      ensureAbLoopRegion();
      updateAbButtonState();
      return;
    }

    if (state.abPointB === null) {
      const playing = isAudioPlaying();
      let targetEnd;
      if (playing) {
        targetEnd = audioPlayer.currentTime;
      } else {
        targetEnd = getCurrentTrackDuration();
        if (!Number.isFinite(targetEnd) || targetEnd <= 0) {
          alert('Track duration is not available yet. Please try again after the audio loads.');
          return;
        }
      }
      const duration = getCurrentTrackDuration();
      if (Number.isFinite(duration) && duration > 0) {
        targetEnd = Math.min(targetEnd, duration);
      }
      if (!Number.isFinite(targetEnd)) {
        targetEnd = state.abPointA + AB_MIN_DURATION;
      }
      if (targetEnd <= state.abPointA + AB_MIN_DURATION) {
        const fallbackDuration = duration ?? state.abPointA + AB_MIN_DURATION;
        targetEnd = Math.min(fallbackDuration, state.abPointA + AB_MIN_DURATION);
      }
      if (targetEnd <= state.abPointA) {
        return;
      }
      state.abPointB = targetEnd;
      state.abRepeatActive = true;
      ensureAbLoopRegion();
      updateAbButtonState();
      enforceAbLoop();
      return;
    }

    resetAbLoop();
  }

  function init() {
    updateAbButtonState();
    setAbButtonEnabled(false);
    if (waveformView && typeof waveformView.setAbRegionUpdateHandler === 'function') {
      waveformView.setAbRegionUpdateHandler((start, end) => {
        state.abPointA = start;
        state.abPointB = end;
        if (!state.abRepeatActive && start !== null && end !== null && end > start) {
          state.abRepeatActive = true;
        }
        updateAbButtonState();
        enforceAbLoop();
      });
    }

    if (waveformView && typeof waveformView.setAbRegionRemovalHandler === 'function') {
      waveformView.setAbRegionRemovalHandler(() => {
        if (state.isClearingAbRegion) {
          return;
        }
        state.abPointA = null;
        state.abPointB = null;
        state.abRepeatActive = false;
        updateAbButtonState();
      });
    }

    if (abButton) {
      abButton.addEventListener('click', handleAbButtonClick);
    }
  }

  return {
    init,
    hasValidAbLoop,
    updateAbButtonState,
    setAbButtonEnabled,
    ensureAbLoopRegion,
    resetAbLoop,
    enforceAbLoop,
    primePlaybackForAbLoop,
    handleAbButtonClick
  };
}

// Source: src/trello-power-up/popup/soundtouch.js
function clearSoundtouchBuffers() {
  if (!state.soundtouchNode || !state.soundtouchNode.port) {
    return;
  }
  try {
    state.soundtouchNode.port.postMessage({ type: 'clearBuffers' });
  } catch (error) {
    console.warn('Failed to clear SoundTouch buffers:', error);
  }
}

function setSoundtouchParam(name, value) {
  if (!state.soundtouchNode || !state.audioContext) return;
  try {
    const param = state.soundtouchNode.parameters?.get(name);
    if (param) {
      param.setValueAtTime(value, state.audioContext.currentTime);
    } else if (state.soundtouchNode.port) {
      state.soundtouchNode.port.postMessage({ type: name, value });
    }
  } catch (error) {
    console.error(`Unable to update ${name} parameter:`, error);
  }
}

function updateSoundtouchPitch(value) {
  setSoundtouchParam('pitchSemitones', value);
}

function updateSoundtouchTempo(value) {
  setSoundtouchParam('tempo', value);
  setSoundtouchParam('rate', 1);
  setSoundtouchParam('pitch', 1);
}

async function resumeAudioContext() {
  if (state.audioContext && state.audioContext.state === 'suspended') {
    try {
      await state.audioContext.resume();
    } catch (error) {
      console.warn('Audio context resume blocked:', error);
    }
  }
}

async function ensureSoundtouchNode() {
  if (state.soundtouchNode) {
    updateSoundtouchTempo(state.desiredPlaybackSpeed);
    updateSoundtouchPitch(state.desiredPitchSemitones);
    return state.soundtouchNode;
  }
  if (!state.audioContext) {
    state.audioContext = new AudioContext();
  }
  if (!state.soundtouchModulePromise) {
    state.soundtouchModulePromise = state.audioContext.audioWorklet
      .addModule('./soundtouch-worklet.js?4')
      .catch((error) => {
        console.error('Failed to load SoundTouch worklet:', error);
        throw error;
      });
  }
  await state.soundtouchModulePromise;
  try {
    state.soundtouchNode = new AudioWorkletNode(state.audioContext, 'soundtouch-processor');
  } catch (error) {
    console.error('Failed to create SoundTouch node:', error);
    state.soundtouchNode = null;
    throw error;
  }
  state.soundtouchNode.connect(state.audioContext.destination);
  if (!state.audioSourceNode) {
    state.audioSourceNode = state.audioContext.createMediaElementSource(dom.audioPlayer);
  } else {
    try {
      state.audioSourceNode.disconnect();
    } catch (error) {
      console.warn('Audio source disconnect failed:', error);
    }
  }
  state.audioSourceNode.connect(state.soundtouchNode);
  updateSoundtouchTempo(state.desiredPlaybackSpeed);
  updateSoundtouchPitch(state.desiredPitchSemitones);
  return state.soundtouchNode;
}

// Source: src/trello-power-up/popup/trello.js
const t = window.TrelloPowerUp.iframe();

// Source: src/trello-power-up/popup/storage.js
function buildPitchStorageKey(attachment) {
  if (!attachment || !attachment.id || !attachment.cardId) {
    return null;
  }
  return `${PITCH_KEY_PREFIX}${attachment.cardId}:${attachment.id}`;
}

async function loadApiKey() {
  return await t.get('board', 'shared', 'apikey');
}

async function saveApiKey(value) {
  return await t.set('board', 'shared', 'apikey', value);
}

async function loadMemberToken() {
  return await t.get('member', 'private', 'token');
}

async function saveMemberToken(token) {
  return await t.set('member', 'private', 'token', token);
}

async function clearMemberToken() {
  return await t.set('member', 'private', 'token', null);
}

async function loadPitchPreference(attachment) {
  const storageKey = buildPitchStorageKey(attachment);
  if (!storageKey) {
    return null;
  }
  try {
    return await t.get('board', 'shared', storageKey);
  } catch (error) {
    console.warn('Failed to load pitch preference:', error);
    return null;
  }
}

async function savePitchPreference(attachment, value) {
  const storageKey = buildPitchStorageKey(attachment);
  if (!storageKey) {
    return;
  }
  try {
    await t.set('board', 'shared', storageKey, value);
  } catch (error) {
    console.error('Failed to save pitch preference:', error);
  }
}

// Source: src/trello-power-up/popup/pitch.js
function clampPitch(value) {
  if (Number.isNaN(value)) return 0;
  return Math.min(PITCH_MAX, Math.max(PITCH_MIN, value));
}

function updatePitchUI(value) {
  if (dom.pitchSlider) dom.pitchSlider.value = String(value);
  if (dom.pitchDisplay) {
    const formatted = value > 0 ? `+${value}` : `${value}`;
    dom.pitchDisplay.textContent = formatted;
  }
}

function setPitchControlsEnabled(enabled) {
  if (dom.pitchSlider) dom.pitchSlider.disabled = !enabled;
}

async function applyPitchValue(value, { persist = false } = {}) {
  const clamped = clampPitch(value);
  state.desiredPitchSemitones = clamped;
  updatePitchUI(clamped);
  try {
    await ensureSoundtouchNode();
    await resumeAudioContext();
    updateSoundtouchPitch(clamped);
  } catch (error) {
    console.warn('Pitch shift unavailable:', error);
  }
  if (persist) {
    const attachment = state.m4aAttachments[state.currentAttachmentIndex];
    if (attachment) {
      await savePitchPreference(attachment, clamped);
    }
  }
}

// Source: src/trello-power-up/popup/playback-speed.js
function clampPlaybackSpeed(value) {
  if (!Number.isFinite(value)) {
    return 1;
  }
  const clamped = Math.min(PLAYBACK_SPEED_MAX, Math.max(PLAYBACK_SPEED_MIN, value));
  const steps = Math.round(clamped / PLAYBACK_SPEED_STEP);
  return Number((steps * PLAYBACK_SPEED_STEP).toFixed(2));
}

function updatePlaybackSpeedUI(value) {
  const formatted = value.toFixed(2);
  if (dom.speedSlider) dom.speedSlider.value = formatted;
  if (dom.speedDisplay) {
    dom.speedDisplay.textContent = `${formatted}x`;
  }
}

function setPlaybackSpeedControlsEnabled(enabled) {
  if (dom.speedSlider) dom.speedSlider.disabled = !enabled;
}

async function applyPlaybackSpeed(value) {
  const clamped = clampPlaybackSpeed(value);
  const previousSpeed = state.desiredPlaybackSpeed;
  state.desiredPlaybackSpeed = clamped;
  updatePlaybackSpeedUI(clamped);
  try {
    await ensureSoundtouchNode();
    await resumeAudioContext();
    if (clamped !== previousSpeed) {
      clearSoundtouchBuffers();
    }
    updateSoundtouchTempo(clamped);
  } catch (error) {
    console.warn('Playback speed adjustment unavailable:', error);
  }
  return clamped;
}

// Source: src/trello-power-up/popup/attachments-ui.js
function clearAttachmentList() {
  if (dom.attachmentsList) {
    dom.attachmentsList.innerHTML = '';
  }
}

function createAttachmentListItem(attachment, onClick) {
  const template = dom.attachmentTemplate;
  if (!template || !template.content) {
    return null;
  }
  const li = template.content.firstElementChild.cloneNode(true);
  li.dataset.attachmentId = attachment.id;
  li.dataset.originalName = attachment.name;
  const nameElement = li.querySelector('.attachment-name');
  if (nameElement) {
    nameElement.textContent = attachment.name;
  }
  li.addEventListener('click', () => {
    onClick(attachment.id);
  });
  return li;
}

function appendAttachmentListItem(element) {
  if (dom.attachmentsList && element) {
    dom.attachmentsList.appendChild(element);
  }
}

function updateAttachmentDurationDisplay(attachmentId) {
  if (!attachmentId || !dom.attachmentsList) {
    return;
  }
  const listItem = dom.attachmentsList.querySelector(`li[data-attachment-id="${attachmentId}"]`);
  if (!listItem) {
    return;
  }
  const nameElement = listItem.querySelector('.attachment-name');
  if (!nameElement) {
    return;
  }
  const originalName = listItem.dataset.originalName || nameElement.textContent;
  listItem.dataset.originalName = originalName;
  const storedDuration = caches.attachmentDurations.get(attachmentId);
  const formattedDuration = formatDuration(storedDuration);
  if (formattedDuration) {
    nameElement.textContent = `(${formattedDuration}) ${originalName}`;
  } else {
    nameElement.textContent = originalName;
  }
}

// Source: src/trello-power-up/popup/audio-cache.js
async function fetchAttachmentBlob(originalUrl) {
  if (!state.trelloToken) {
    throw new Error('Missing Trello token');
  }
  const proxiedUrl = `${PROXY_URL}?url=${encodeURIComponent(originalUrl)}`;
  const auth = `OAuth oauth_consumer_key="${state.apiKey}", oauth_token="${state.trelloToken}"`;
  const response = await fetch(proxiedUrl, {
    headers: {
      'x-trello-auth': auth
    }
  });
  if (!response.ok) {
    throw new Error(`Proxy request failed with status ${response.status}`);
  }
  return await response.blob();
}

function trimAudioCache(preserveIds = []) {
  if (caches.audioBlobCache.size <= AUDIO_CACHE_LIMIT) {
    return;
  }
  const preserveSet = new Set(preserveIds.filter(Boolean));
  for (const [attachmentId] of caches.audioBlobCache) {
    if (caches.audioBlobCache.size <= AUDIO_CACHE_LIMIT) {
      break;
    }
    if (preserveSet.has(attachmentId)) {
      preserveSet.delete(attachmentId);
      continue;
    }
    caches.audioBlobCache.delete(attachmentId);
  }
}

function fetchAndCacheAttachment(attachment) {
  if (!attachment) {
    return null;
  }
  if (!caches.audioBlobCache.has(attachment.id)) {
    const downloadPromise = fetchAttachmentBlob(attachment.url);
    caches.audioBlobCache.set(attachment.id, downloadPromise);
    trimAudioCache([attachment.id, state.m4aAttachments[state.currentAttachmentIndex]?.id]);
    downloadPromise.catch(() => {
      if (caches.audioBlobCache.get(attachment.id) === downloadPromise) {
        caches.audioBlobCache.delete(attachment.id);
      }
    });
  }
  return caches.audioBlobCache.get(attachment.id);
}

async function getAttachmentBlob(attachment) {
  const blobPromise = fetchAndCacheAttachment(attachment);
  if (!blobPromise) {
    throw new Error('Unable to resolve attachment blob');
  }
  return await blobPromise;
}

function prefetchAttachment(index) {
  if (index < 0 || index >= state.m4aAttachments.length) {
    return;
  }
  fetchAndCacheAttachment(state.m4aAttachments[index]);
}

function prefetchAdjacent(index) {
  prefetchAttachment(index + 1);
  prefetchAttachment(index - 1);
}

function revokeCurrentObjectUrl() {
  if (state.currentObjectUrl) {
    URL.revokeObjectURL(state.currentObjectUrl);
    state.currentObjectUrl = null;
  }
}

function clearAudioCache() {
  caches.audioBlobCache.clear();
}

// Source: src/trello-power-up/popup/scroll.js
function clampScrollTarget(container, target) {
  const maxScroll = Math.max(container.scrollHeight - container.clientHeight, 0);
  return Math.max(0, Math.min(target, maxScroll));
}

function scrollActiveAttachmentIntoView(list, { direction = null } = {}) {
  if (!list) {
    return;
  }
  const activeItem = list.querySelector('li.active');
  if (!activeItem) {
    return;
  }
  const containerHeight = list.clientHeight;
  if (containerHeight <= 0) {
    return;
  }

  const containerRect = list.getBoundingClientRect();
  const itemRect = activeItem.getBoundingClientRect();
  const scrollTop = list.scrollTop;
  const itemTop = scrollTop + itemRect.top - containerRect.top;
  const containerMiddle = scrollTop + containerHeight / 2;
  const itemHeight = activeItem.offsetHeight;
  const itemBottom = itemTop + itemHeight;
  const itemCenter = itemTop + itemHeight / 2;
  const isBelowView = itemBottom > scrollTop + containerHeight;
  const isAboveView = itemTop < scrollTop;
  let shouldAdjust = false;

  if (direction === 'forward') {
    shouldAdjust = itemCenter > containerMiddle;
  } else if (direction === 'backward') {
    shouldAdjust = itemCenter < containerMiddle;
  } else {
    shouldAdjust = isBelowView || isAboveView;
  }

  if (!shouldAdjust) {
    return;
  }

  const target = clampScrollTarget(list, itemCenter - containerHeight / 2);
  list.scrollTo({ top: target, behavior: 'smooth' });
}

// Source: src/trello-power-up/popup/song-source.js
const SUPPORTED_AUDIO_EXTENSIONS = ['.m4a', '.mp3'];

function isSupportedAttachment(attachment) {
  return SUPPORTED_AUDIO_EXTENSIONS.some((ext) => attachment.url?.toLowerCase().endsWith(ext));
}

async function fetchSongAttachments({ apiKey, token }) {
  const listInfo = await t.list('id');
  const response = await fetch(
    `https://api.trello.com/1/lists/${listInfo.id}/cards?attachments=true&key=${apiKey}&token=${token}`
  );
  if (!response.ok) {
    throw new Error(`Trello responded with status ${response.status}`);
  }
  const cards = await response.json();
  const attachments = [];
  cards.forEach((card) => {
    const cardAttachments = card.attachments
      .filter(isSupportedAttachment)
      .map((attachment) => ({ ...attachment, cardId: card.id }));
    attachments.push(...cardAttachments);
  });
  return attachments;
}

// Source: src/trello-power-up/popup/player.js
function updatePlayPauseButton() {
  if (!dom.playPauseButton) return;
  if (dom.audioPlayer && !dom.audioPlayer.paused && !dom.audioPlayer.ended && dom.audioPlayer.currentTime >= 0) {
    dom.playPauseButton.innerHTML = '&#x23F8;&#xFE0E;';
    dom.playPauseButton.title = 'Pause';
  } else {
    dom.playPauseButton.innerHTML = '&#x25B6;&#xFE0E;';
    dom.playPauseButton.title = 'Play';
  }
}

function updateSettingsControlsAvailability() {
  const audioReady = state.isAudioLoaded;
  setPitchControlsEnabled(audioReady);
  setPlaybackSpeedControlsEnabled(audioReady);
}

function showWaveform(audioUrl) {
  if (!dom.waveformView) return;
  dom.waveformView.clear();
  dom.waveformView.hideStatus();
  dom.waveformView.showLoading();
  dom.waveformView.setWrenchHandler(openWaveformModal);
  try {
    dom.waveformView.loadFromUrl(audioUrl, {
      interact: true,
      media: dom.audioPlayer
    });
  } catch (error) {
    console.error('Failed to render waveform:', error);
  }
}

function openWaveformModal() {
  if (!dom.modal) return;
  dom.modal.classList.remove('hidden');
  dom.modal.focus();
}

function closeModal() {
  if (!dom.modal) return;
  dom.modal.classList.add('hidden');
}

function handleOutsideModalClick(event) {
  if (event.target === dom.modal) {
    closeModal();
  }
}

async function prepareAudioProcessorsOnPlay() {
  updatePlayPauseButton();
  await ensureSoundtouchNode();
  updateSoundtouchTempo(state.desiredPlaybackSpeed);
  updateSoundtouchPitch(state.desiredPitchSemitones);
  await resumeAudioContext();
}

async function loadAttachment(index, { autoplay = true, scrollToTop = false } = {}, abLoop) {
  if (index < 0 || index >= state.m4aAttachments.length) {
    return;
  }

  const previousIndex = state.currentAttachmentIndex;
  const previousSpeed = state.desiredPlaybackSpeed;
  const previousAudioLoaded = state.isAudioLoaded;
  abLoop.resetAbLoop();
  abLoop.setAbButtonEnabled(false);
  state.currentAttachmentIndex = index;
  const loadToken = ++state.currentLoadRequest;
  const attachment = state.m4aAttachments[index];
  state.isAudioLoaded = false;
  updateSettingsControlsAvailability();

  const listItems = dom.attachmentsList?.querySelectorAll('li') ?? [];
  const direction = index > previousIndex ? 'forward' : index < previousIndex ? 'backward' : null;
  listItems.forEach((item, idx) => {
    item.classList.toggle('active', idx === index);
  });

  if (scrollToTop && dom.attachmentsList) {
    dom.attachmentsList.scrollTop = 0;
  } else if (dom.attachmentsList) {
    scrollActiveAttachmentIntoView(dom.attachmentsList, { direction });
  }

  dom.waveformView?.hideStatus();
  dom.waveformView?.showLoading();
  let audioBlob;
  let audioUrl;
  try {
    dom.audioPlayer.pause();
    clearSoundtouchBuffers();
    audioBlob = await getAttachmentBlob(attachment);
    if (loadToken !== state.currentLoadRequest) {
      return;
    }
    audioUrl = URL.createObjectURL(audioBlob);
    revokeCurrentObjectUrl();
    state.currentObjectUrl = audioUrl;
    dom.audioPlayer.src = audioUrl;
    dom.audioPlayer.load();
    dom.audioPlayer.dataset.attachmentId = attachment.id;
    dom.audioPlayer.dataset.loadToken = String(loadToken);
    showWaveform(audioUrl);
    abLoop.setAbButtonEnabled(true);
    const storedPitch = await loadPitchPreference(attachment);
    const pitchValue = Number(storedPitch);
    await applyPitchValue(Number.isFinite(pitchValue) ? pitchValue : 0);
    await applyPlaybackSpeed(1);
    state.isAudioLoaded = true;
    updateSettingsControlsAvailability();
    prefetchAdjacent(index);
    if (autoplay) {
      const playPromise = dom.audioPlayer.play();
      if (playPromise !== undefined) {
        playPromise.catch((error) => {
          console.warn('Playback start was blocked:', error);
          dom.waveformView?.showStatus('Press play or choose a track to start playback.');
        });
      }
    } else {
      dom.audioPlayer.pause();
      dom.audioPlayer.currentTime = 0;
      updatePlayPauseButton();
    }
  } catch (error) {
    if (audioUrl && audioUrl !== state.currentObjectUrl) {
      URL.revokeObjectURL(audioUrl);
    }
    console.error('Failed to load attachment audio:', error);
    alert('Failed to load audio attachment. Please try again.');
    state.currentAttachmentIndex = previousIndex;
    listItems.forEach((item, idx) => {
      item.classList.toggle('active', idx === state.currentAttachmentIndex);
    });
    state.desiredPlaybackSpeed = previousSpeed;
    updatePlaybackSpeedUI(state.desiredPlaybackSpeed);
    updateSoundtouchTempo(state.desiredPlaybackSpeed);
    state.isAudioLoaded = previousAudioLoaded;
    updateSettingsControlsAvailability();
    updatePitchUI(state.desiredPitchSemitones);
    if (loadToken === state.currentLoadRequest) {
      dom.waveformView?.hideLoading();
    }
    abLoop.setAbButtonEnabled(state.m4aAttachments.length > 0);
  }
}

async function loadPlayer(abLoop) {
  try {
    clearAudioCache();
    state.m4aAttachments = [];
    clearAttachmentList();
    caches.attachmentDurations.clear();
    abLoop.resetAbLoop();
    abLoop.setAbButtonEnabled(false);
    state.isAudioLoaded = false;
    updateSettingsControlsAvailability();
    state.desiredPlaybackSpeed = 1;
    updatePlaybackSpeedUI(state.desiredPlaybackSpeed);
    const attachments = await fetchSongAttachments({ apiKey: state.apiKey, token: state.trelloToken });
    state.m4aAttachments.push(...attachments);
    state.isAudioLoaded = false;
    updateSettingsControlsAvailability();
    state.m4aAttachments.forEach((attachment) => {
      const element = createAttachmentListItem(attachment, (id) => {
        const targetIndex = state.m4aAttachments.findIndex((att) => att.id === id);
        loadAttachment(targetIndex, {}, abLoop);
      });
      appendAttachmentListItem(element);
      updateAttachmentDurationDisplay(attachment.id);
    });

    if (state.m4aAttachments.length > 0) {
      await loadAttachment(0, {}, abLoop);
    } else {
      dom.waveformView?.clear();
      revokeCurrentObjectUrl();
      dom.audioPlayer.pause();
      dom.audioPlayer.removeAttribute('src');
      dom.audioPlayer.load();
      updatePitchUI(0);
      state.desiredPlaybackSpeed = 1;
      updatePlaybackSpeedUI(state.desiredPlaybackSpeed);
      state.isAudioLoaded = false;
      updateSettingsControlsAvailability();
      abLoop.resetAbLoop();
      abLoop.setAbButtonEnabled(false);
    }
  } catch (error) {
    console.error('Error fetching attachments:', error);
    alert('Failed to load attachments. Please try again.');
    abLoop.resetAbLoop();
    abLoop.setAbButtonEnabled(false);
    state.isAudioLoaded = false;
    updateSettingsControlsAvailability();
  }
}

function createPlayerController(abLoop) {
  function init() {
    updatePlayPauseButton();
    updatePitchUI(state.desiredPitchSemitones);
    updatePlaybackSpeedUI(state.desiredPlaybackSpeed);
    state.isAudioLoaded = false;
    updateSettingsControlsAvailability();

    dom.prevButton?.addEventListener('click', () => {
      if (state.currentAttachmentIndex > 0) {
        loadAttachment(state.currentAttachmentIndex - 1, {}, abLoop);
      }
    });

    dom.nextButton?.addEventListener('click', () => {
      if (state.currentAttachmentIndex < state.m4aAttachments.length - 1) {
        loadAttachment(state.currentAttachmentIndex + 1, {}, abLoop);
      }
    });

    if (dom.playPauseButton) {
      dom.playPauseButton.addEventListener('click', () => {
        if (dom.audioPlayer.paused || dom.audioPlayer.ended) {
          dom.audioPlayer.play();
        } else {
          dom.audioPlayer.pause();
        }
      });
    }

    dom.stopButton?.addEventListener('click', () => {
      dom.audioPlayer.pause();
      dom.audioPlayer.currentTime = 0;
    });

    dom.cancelBtn?.addEventListener('click', closeModal);
    dom.modal?.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        closeModal();
      }
    });
    dom.modal?.addEventListener('click', handleOutsideModalClick);
    dom.modal?.addEventListener('touchstart', handleOutsideModalClick);

    dom.audioPlayer.addEventListener('ended', () => {
      updatePlayPauseButton();
      if (abLoop.hasValidAbLoop()) {
        dom.audioPlayer.currentTime = state.abPointA ?? 0;
        dom.audioPlayer.play().catch(() => {});
        return;
      }
      if (state.currentAttachmentIndex < state.m4aAttachments.length - 1) {
        loadAttachment(state.currentAttachmentIndex + 1, { autoplay: true }, abLoop);
      } else if (state.m4aAttachments.length > 0) {
        loadAttachment(0, { autoplay: false, scrollToTop: true }, abLoop);
      }
    });

    dom.audioPlayer.addEventListener('loadedmetadata', () => {
      const attachmentId = dom.audioPlayer.dataset.attachmentId;
      const loadToken = Number(dom.audioPlayer.dataset.loadToken);
      if (!attachmentId || loadToken !== state.currentLoadRequest) {
        return;
      }
      const duration = dom.audioPlayer.duration;
      if (!Number.isFinite(duration) || duration <= 0) {
        return;
      }
      caches.attachmentDurations.set(attachmentId, duration);
      updateAttachmentDurationDisplay(attachmentId);
    });

    dom.audioPlayer.addEventListener('play', async () => {
      try {
        await prepareAudioProcessorsOnPlay();
      } catch (error) {
        console.warn('Unable to prepare pitch processor on play:', error);
      }
      abLoop.primePlaybackForAbLoop();
    });

    dom.audioPlayer.addEventListener('playing', () => {
      dom.waveformView?.hideStatus();
      updatePlayPauseButton();
    });

    dom.audioPlayer.addEventListener('pause', () => {
      clearSoundtouchBuffers();
      updatePlayPauseButton();
    });

    dom.audioPlayer.addEventListener('seeked', () => {
      clearSoundtouchBuffers();
      abLoop.enforceAbLoop();
    });

    dom.audioPlayer.addEventListener('loadstart', () => {
      clearSoundtouchBuffers();
      updatePlayPauseButton();
    });

    dom.audioPlayer.addEventListener('timeupdate', () => {
      abLoop.enforceAbLoop();
    });

    if (dom.pitchSlider) {
      dom.pitchSlider.addEventListener('input', (event) => {
        const value = Number(event.target.value);
        applyPitchValue(value);
      });
      dom.pitchSlider.addEventListener('change', (event) => {
        const value = Number(event.target.value);
        applyPitchValue(value, { persist: true });
      });
    }

    if (dom.speedSlider) {
      dom.speedSlider.addEventListener('input', (event) => {
        const value = Number(event.target.value);
        applyPlaybackSpeed(value);
      });
      dom.speedSlider.addEventListener('change', (event) => {
        const value = Number(event.target.value);
        applyPlaybackSpeed(value);
      });
    }

    window.addEventListener('unload', revokeCurrentObjectUrl);
  }

  return {
    init,
    loadPlayer: () => loadPlayer(abLoop),
    loadAttachment: (index, options) => loadAttachment(index, options, abLoop),
    updatePlayPauseButton
  };
}

// Source: src/trello-power-up/popup/auth.js
function isValidToken(token) {
  const isString = typeof token === 'string';
  const isTest = /^[a-zA-Z0-9]{64,80}$/i.test(token);
  return isString && isTest;
}

async function validateToken(key, token) {
  if (!key || !token) return false;
  try {
    const resp = await fetch(`https://api.trello.com/1/members/me?key=${key}&token=${token}`);
    return resp.status === 200;
  } catch {
    return false;
  }
}

function showAuthForm() {
  dom.authForm?.classList.remove('hidden');
  dom.attachmentsContainer?.classList.add('hidden');
}

function hideAuthForm() {
  dom.authForm?.classList.add('hidden');
  dom.attachmentsContainer?.classList.remove('hidden');
}

function setupAuth(player) {
  async function handleAuthorizeClick() {
    const key = dom.apiKeyInput?.value.trim() ?? '';
    state.apiKey = key;
    await saveApiKey(key);
    const returnUrl = window.location.href.split('#')[0];
    const authUrl = () =>
      'https://trello.com/1/authorize?expiration=never' +
      '&scope=read&key=' + encodeURIComponent(key) +
      '&callback_method=postMessage' +
      '&return_url=' + encodeURIComponent(returnUrl);

    if (state.authMessageHandler) {
      window.removeEventListener('message', state.authMessageHandler);
      state.authMessageHandler = null;
    }

    state.authMessageHandler = async (event) => {
      if (!state.popup || event.source !== state.popup) return;
      const token = typeof event.data === 'string' ? event.data.trim() : '';
      if (!isValidToken(token)) return;
      window.removeEventListener('message', state.authMessageHandler);
      state.authMessageHandler = null;
      if (!(await validateToken(key, token))) {
        alert('Failed to validate Trello authorization. Please try again.');
        state.popup?.close();
        state.popup = null;
        return;
      }
      await saveMemberToken(token);
      state.popup?.close();
      state.popup = null;
      location.reload();
    };

    window.addEventListener('message', state.authMessageHandler);

    try {
      await t.authorize(authUrl, {
        validToken: isValidToken,
        windowCallback: (win) => {
          state.popup = win;
        }
      });
    } catch (error) {
      window.removeEventListener('message', state.authMessageHandler);
      state.authMessageHandler = null;
      state.popup = null;
      console.error('Authorization popup failed to open:', error);
    }
  }

  dom.authorizeBtn?.addEventListener('click', handleAuthorizeClick);

  dom.apiKeyInput?.addEventListener('change', () => {
    state.apiKey = dom.apiKeyInput.value.trim();
    saveApiKey(state.apiKey).catch((error) => {
      console.warn('Failed to persist API key change:', error);
    });
  });

  async function initAuth() {
    const key = await loadApiKey();
    if (key && dom.apiKeyInput) {
      dom.apiKeyInput.value = key;
    }
    state.apiKey = dom.apiKeyInput?.value.trim() ?? '';

    const hashMatch = window.location.hash.match(/token=([^&]+)/);
    if (hashMatch) {
      await saveMemberToken(hashMatch[1]);
      window.location.hash = '';
    }

    const token = await loadMemberToken();
    if (token && (await validateToken(state.apiKey, token))) {
      hideAuthForm();
      state.trelloToken = token;
      await player.loadPlayer();
    } else {
      if (token) {
        await clearMemberToken();
      }
      showAuthForm();
    }
  }

  return {
    initAuth
  };
}

// Source: src/trello-power-up/popup/index.js
registerWaveformPreview();

const abLoop = createAbLoopController();
abLoop.init();

const player = createPlayerController(abLoop);
player.init();

const { initAuth } = setupAuth(player);
initAuth();

})();
